{"componentChunkName":"component---src-templates-blog-post-js","path":"/arknights-auto/","result":{"data":{"site":{"siteMetadata":{"title":"NARAZUKE","author":[{"name":"nozzle","summary":"who lives in gummaken.","social":{"github":"nozzlex3"}},{"name":"konnyaku","summary":"who is known as Siege Sukosuko Samurai.","social":{"github":"wabetarou"}}]}},"markdownRemark":{"id":"b2963871-50ac-5dc7-b622-8230342cce9f","excerpt":"アークナイツ自動化のツールを作る際の履歴をメモしたもの。 python で pyautogui(pyscreeze)を使って作ったがどうやらlocateOnScreen時に毎回 screenshot をとっていて、非効率だし pc に負担かかりそう。なのでせっかくの機会なので c…","html":"<p>アークナイツ自動化のツールを作る際の履歴をメモしたもの。</p>\n<p>python で pyautogui(pyscreeze)を使って作ったがどうやら<code>locateOnScreen</code>時に毎回 screenshot をとっていて、非効率だし pc に負担かかりそう。なのでせっかくの機会なので c++を使って新しく自動化機能を作りたいと思う。ちなみに下のコードが python で作ったコード。</p>\n<pre><code class=\"language-python\">import time,pyautogui\n\nstart = time.time()\nflag = 0\nwhile(1):\n    print(\"\\n\"+str(int(time.time()-start))+\"秒経過\")\n    autoPos = pyautogui.locateCenterOnScreen(\"./image/auto.png\", grayscale=True)\n    stageDecidePos = pyautogui.locateCenterOnScreen(\"./image/stage_decide.png\", grayscale=True)\n    stageStartPos = pyautogui.locateCenterOnScreen(\"./image/stage_start.png\", grayscale=True)\n    resultPos = pyautogui.locateCenterOnScreen(\"./image/result.png\", grayscale=True)\n    if autoPos is not None:\n        pyautogui.click(stageDecidePos[0],stageDecidePos[1])\n        print(\"click stageDecide\")\n        flag = 0\n    elif stageStartPos is not None:\n        pyautogui.click(stageStartPos[0],stageStartPos[1])\n        print(\"click stageStart\")\n        time.sleep(90)\n        flag = 0\n    elif resultPos is not None:\n        pyautogui.click(resultPos[0],resultPos[1])\n        print(\"click result\")\n        flag = 0\n    else:\n        flag += 1\n        if flag > 20:\n            break\n    time.sleep(3)\n</code></pre>\n<h3>openCV を動かす</h3>\n<p>いろいろつまづいたが次の手順でやれば良い</p>\n<p>1.Homebrew でインストール</p>\n<pre><code>brew install opencv\nbrew install pkg-config\n</code></pre>\n<p>2.コードを書く</p>\n<pre><code class=\"language-cpp\">#include &#x3C;stdio.h>\n#include &#x3C;opencv2/opencv.hpp>\n\nint main() {\n cv::Mat img;\n\n img = cv::imread(\"example.png\");\n\n cv::imshow(\"title\", img);\n cv::waitKey(0);\n\n return 0;\n}\n</code></pre>\n<p>3.コンパイル &#x26; 実行</p>\n<pre><code>g++ -std=c++11 main.cpp `pkg-config --cflags opencv4` `pkg-config --libs opencv4`\n./a.out\n</code></pre>\n<h3>マウスのポジションとクリック</h3>\n<p>CoreGraphics.h をつかいたいが以下のエラーが出る</p>\n<pre><code>Undefined symbols for architecture x86_64:\n  \"_CFRelease\", referenced from:\n      _main in main-63de17.o\n  \"_CGEventCreate\", referenced from:\n      _main in main-63de17.o\n  \"_CGEventGetLocation\", referenced from:\n      _main in main-63de17.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n<p>このエラーは opencv の場合では pkg-config を入れることで治った。ヘッダファイルの場所の指定、ライブラリの場所の指定、リンクするライブラリの指定をしているらしい。\n(参考)<a href=\"https://ja.stackoverflow.com/questions/53767/macos-c%E3%81%A7opencv%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84\">MacOS c++で openCV が実行できない</a></p>\n<p>だが CoreGraphics では pkg-config が使えないため直接オプションを指定する必要がありそうだ。<a href=\"https://stackoverflow.com/questions/18882483/implement-part-of-c-source-code\">https://stackoverflow.com/questions/18882483/implement-part-of-c-source-code</a></p>\n<p>最終的には<code>-framework</code>によって無事コンパイルできた。</p>\n<pre><code>g++ -std=c++11 -framework CoreGraphics -framework CoreFoundation main.cpp `pkg-config --cflags opencv4` `pkg-config --libs opencv4`\n</code></pre>\n<p>実際のコードは以下のリンクを参考にした。</p>\n<p>（ポジションについて）<a href=\"https://gist.github.com/mhamilt/7209c809c03e42a7027e9fe5b18fdfa2\">mhamilt/get<em>mouse</em>position_macos.cpp</a><br>\n（クリックについて）<a href=\"https://stackoverflow.com/questions/1483657/performing-a-double-click-using-cgeventcreatemouseevent\">Performing a double click using CGEventCreateMouseEvent()</a></p>\n<h3>画像認識について</h3>\n<p>マウスのポジションを指定してクリックすることはできたので次は指定する画像が存在するか、またどこにあるかを認識できるようにしないといけない。どうしよう。\nOpenCV でそういうことできないか調べた。\n<a href=\"https://qiita.com/anzanshi/items/82fc4c7a3a1f84137aef\">Python OpenCV で画像を検索、判定結果を返してみた</a>\npython だけど参考になった。どうやら<code>matchTemplate</code>が画像の一部が指定の画像と一致するかを判定する関数のようだ。</p>\n<h3>構造体</h3>\n<p>構造体関連でつまづいた。</p>\n<pre><code>main.cpp:120:25: error: member access into incomplete type 'struct CGImage'\n    CGFloat cols = image->width;\n                        ^\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/System/Library/Frameworks/CoreGraphics.framework/Headers/CGImage.h:12:36: note:\n      forward declaration of 'CGImage'\ntypedef struct CF_BRIDGED_TYPE(id) CGImage *CGImageRef;\n                                   ^\n</code></pre>\n<p>結局<code>CGImageGetWidth()</code>というライブライ関数を使ってどうにかなったけど上のエラーはよくわからないまま。</p>\n<h3>ウィンドウ探索</h3>\n<p>CoreGraphics での window 探索について\n(参考)<a href=\"https://gist.github.com/Recognition101/1e28655eece7f1169951\">Recognition101/appNames.cpp</a></p>\n<h3>CoreGraphics</h3>\n<p>CoreGraphics 関連がわからなすぎるのでまとめる。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">func name</th>\n<th align=\"center\">return</th>\n<th align=\"center\">やること</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>CGMainDisplayID()</code></td>\n<td align=\"center\"><code>CGDirectDisplayID</code></td>\n<td align=\"center\">main_display の ID を返す</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CGDisplayBounds(CGDirectDisplayID)</code></td>\n<td align=\"center\"><code>CGRect</code></td>\n<td align=\"center\">display の rect を返す</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CGDisplayCreateImage(CGDirectDisplayID)</code></td>\n<td align=\"center\"><code>CGImage</code></td>\n<td align=\"center\">cgimage を返す</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CGDisplayCreateImage(CGDirectDisplayID, CGRect)</code></td>\n<td align=\"center\"><code>CGImage</code></td>\n<td align=\"center\">範囲指定</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CGImageGetColorSpace(CGImageRef)</code></td>\n<td align=\"center\"><code>CGColorSpaceRef</code></td>\n<td align=\"center\">わからん</td>\n</tr>\n<tr>\n<td align=\"center\"><code>CGBitmapContextCreate(...)</code></td>\n<td align=\"center\"><code>CGContextRef</code></td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<p>CoreGraphics の画像を opencv の Mat に変換する関数をつくったがでうまく書き込めず真っ黒になる。。。</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\nCoreGraphicsを使う方法を諦めた。諦めたらすっきりした。\n<p>スクリーンショットを<code>system()</code>でとる方法に切り替える。</p>\n<h3>構成</h3>\n<p>以下のような順番の構成で自動化ツールを作った。</p>\n<ol>\n<li>スクリーンショットをとる</li>\n<li>用意した画像が存在するか調べる</li>\n<li>存在する場合、位置を調べる</li>\n<li>その位置をクリックする</li>\n</ol>\n<pre><code class=\"language-cpp\">#include &#x3C;ApplicationServices/ApplicationServices.h>\n#include &#x3C;opencv2/opencv.hpp>\n#include &#x3C;iostream>\n#include &#x3C;string>\n#include &#x3C;time.h>\n#include &#x3C;unistd.h>\n#include &#x3C;chrono>\n\nusing namespace std::chrono;\ntypedef struct CGPoint CGPoint;\n// g++ -std=c++11 -03 -framework CoreGraphics -framework CoreFoundation main.cpp `pkg-config --cflags opencv4` `pkg-config --libs opencv4`\n\nvoid click(CGPoint);\n\nint main(void) {\n    clock_t p_start = clock();\n    auto start = std::chrono::system_clock::now();\n\n    double maxVal;\n    cv::Point maxLoc;\n    cv::Mat result;\n    cv::Mat screen;\n    CGPoint location;\n\n    cv::Mat img_auto;\n    cv::Mat img_result;\n    cv::Mat img_stage_decide;\n    cv::Mat img_stage_start;\n    cv::Mat img_line;\n\n    img_auto = cv::imread(\"./image/auto.png\",0);\n    img_result = cv::imread(\"./image/result.png\",0);\n    img_stage_decide = cv::imread(\"./image/stage_decide.png\",0);\n    img_stage_start = cv::imread(\"./image/stage_start.png\",0);\n\n    double threshold = 0.999;\n\n    printf(\"start\\n\");\n    int flag_end = 0;\n    int flag_click = 0;\n    while (true) {\n        system(\"screencapture -x ./image/screenshot.png\");\n        screen = cv::imread(\"./image/screenshot.png\",0);\n\n        cv::matchTemplate(screen, img_auto, result, cv::TM_CCORR_NORMED);\n        cv::minMaxLoc(result, NULL, &#x26;maxVal , NULL, NULL);\n        if (maxVal > threshold) {\n            cv::matchTemplate(screen, img_stage_decide, result, cv::TM_CCORR_NORMED);\n            cv::minMaxLoc(result, NULL, NULL , NULL, &#x26;maxLoc);\n            location.x = maxLoc.x;\n            location.y = maxLoc.y;\n            click(location);\n            std::cout &#x3C;&#x3C; \"clicked stage_desicde\\n\";\n            flag_click++;\n        }\n        if (!flag_click) {\n            cv::matchTemplate(screen, img_stage_start, result, cv::TM_CCORR_NORMED);\n            cv::minMaxLoc(result, NULL, &#x26;maxVal , NULL, &#x26;maxLoc);\n            if (maxVal > threshold) {\n                location.x = maxLoc.x;\n                location.y = maxLoc.y;\n                click(location);\n                std::cout &#x3C;&#x3C; \"clicked stage_start\\n\";\n                flag_click++;\n                sleep(90);\n            }\n        }\n        if (!flag_click) {\n            cv::matchTemplate(screen, img_result, result, cv::TM_CCORR_NORMED);\n            cv::minMaxLoc(result, NULL, &#x26;maxVal , NULL, &#x26;maxLoc);\n            if (maxVal > threshold) {\n                location.x = maxLoc.x;\n                location.y = maxLoc.y;\n                click(location);\n                std::cout &#x3C;&#x3C; \"clicked result\\n\";\n                flag_click++;\n            }\n        }\n        if (!flag_click) {\n            flag_end++;\n            if (flag_end > 30) break;\n        } else {\n            flag_click = 0;\n            flag_end = 0;\n        }\n        sleep(5);\n        auto end = system_clock::now();\n        auto dur = end - start;        // 要した時間を計算\n        auto msec = duration_cast&#x3C;milliseconds>(dur).count();\n        // 要した時間をミリ秒（1/1000秒）に変換して表示\n        std::cout &#x3C;&#x3C; msec/1000.0;\n        clock_t p_end = clock();\n        std::cout &#x3C;&#x3C; \"(\" &#x3C;&#x3C; (double)(p_end - p_start) / CLOCKS_PER_SEC &#x3C;&#x3C; \") 秒経過\\n\";\n    }\n}\nvoid click(CGPoint location) {\n    CGEventRef event = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDown, location, kCGMouseButtonLeft);\n    CGEventSetIntegerValueField(event, kCGMouseEventClickState, 1);\n    CGEventPost(kCGHIDEventTap, event);\n    CGEventSetType(event, kCGEventLeftMouseUp);\n    CGEventPost(kCGHIDEventTap, event);\n    CFRelease(event);\n}\n</code></pre>\n<h3>結果</h3>\n<p>前のプログラムより断然早くなった^_^</p>\n<p><img src=\"./result.png\"></p>\n<p>一回のループに対して今回のコードでは約 0.15s であるのに対して、以前のコードでは約 1.4s であるためほぼ 10 倍早くなっている。</p>\n<p>現在は一つのステージだけを周回するプログラムだが、改良することで基地や任務なども自動化できそうのでいつかやるかもしれない。</p>\n<h3>追記（2021/2/20）</h3>\n<p><code>brew doctor</code>を実行して解決したせいか、次のエラーがでる</p>\n<pre><code class=\"language-shell\">kg-config --cflags opencv` `pkg-config --libs opencv` \nPackage opencv was not found in the pkg-config search path.\nPerhaps you should add the directory containing `opencv.pc'\nto the PKG_CONFIG_PATH environment variable\nNo package 'opencv' found\nPackage opencv was not found in the pkg-config search path.\nPerhaps you should add the directory containing `opencv.pc'\nto the PKG_CONFIG_PATH environment variable\nNo package 'opencv' found\nmain.cpp:2:10: fatal error: 'opencv2/opencv.hpp' file not found\n#include &#x3C;opencv2/opencv.hpp>\n         ^~~~~~~~~~~~~~~~~~~~\n1 error generated.\n</code></pre>\n<p>configのpathが通っていないのでそれを設定すればいいようだ</p>\n<p>(参考)<a href=\"https://compmemo.wordpress.com/2014/07/21/linux%E3%81%A7opencv%E3%81%AEpkg-config%E3%82%92%E4%BD%BF%E3%81%8A%E3%81%86%E3%81%A8%E3%81%99%E3%82%8B%E3%81%A8package-opencv-was-not-found-in-the-pkg-config-search-path/\">LinuxでOpencvのpkg-configを使おうとするとPackage opencv was not found in the pkg-config search path.</a></p>\n<pre><code class=\"language-shell\">export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig\n</code></pre>\n<p>これで解決した</p>","fields":{"slug":"/arknights-auto/"},"frontmatter":{"title":"アークナイツ周回の自動化(Mac,C++)","created":"2021-02-04 19:29","updated":"2021-02-20T09:42","description":"C++,openCVを使って自動化","tag":["game","arknights","memo"],"author":["konnyaku"],"category":"tech"}},"previous":{"fields":{"slug":"/kon20210204/"},"frontmatter":{"title":"日記"}},"next":{"fields":{"slug":"/blog-service-impression/"},"frontmatter":{"title":"ブログサービス所感"}},"relatedPosts":{"totalCount":11,"edges":[{"node":{"fields":{"slug":"/raspberrypi-setting-memo/"},"frontmatter":{"title":"ラズパイ環境設定メモ"}}},{"node":{"fields":{"slug":"/game-streaming-impression/"},"frontmatter":{"title":"ゲーム配信所感"}}},{"node":{"fields":{"slug":"/mac-backslash/"},"frontmatter":{"title":"Macでバックスラッシュを入力する"}}},{"node":{"fields":{"slug":"/mac-setting-memo/"},"frontmatter":{"title":"M1 Mac環境構築メモ"}}},{"node":{"fields":{"slug":"/smabro-sp-shulk/"},"frontmatter":{"title":"シュルクのコンボ"}}},{"node":{"fields":{"slug":"/gitclone-to-mygithub/"},"frontmatter":{"title":"gitで別のリポジトリからファイルをコピーする"}}},{"node":{"fields":{"slug":"/chinese/"},"frontmatter":{"title":"中国語メモ"}}},{"node":{"fields":{"slug":"/arknights-logo/"},"frontmatter":{"title":"アークナイツのロゴについて"}}},{"node":{"fields":{"slug":"/arknights-auto/"},"frontmatter":{"title":"アークナイツ周回の自動化(Mac,C++)"}}},{"node":{"fields":{"slug":"/vim-command/"},"frontmatter":{"title":"Vimのコマンド"}}},{"node":{"fields":{"slug":"/arknights-recruit/"},"frontmatter":{"title":"アークナイツの公開求人"}}}]}},"pageContext":{"id":"b2963871-50ac-5dc7-b622-8230342cce9f","previousPostId":"15f85175-e64c-596a-8e76-25dd56890834","nextPostId":"30516e87-e308-5a4e-a9c0-764e3401eb43","category":"tech","tagList":["game","arknights","memo"]}},"staticQueryHashes":["3284037645","500847697"]}